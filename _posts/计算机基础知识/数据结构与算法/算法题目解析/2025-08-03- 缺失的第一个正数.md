---
layout: post
title:  "LeetCode: 41. 缺失的第一个正数"
date:   2025-08-03 22:47:14 +0800
categories: LeetCode 算法
---
## 41. 缺失的第一个正数

### 题目描述

```
给你一个未排序的整数数组 nums ，请你找出其中没有出现的最小的正整数。
请你实现时间复杂度为 O(n) 并且只使用常数级别额外空间的解决方案。 
```

### 思考：

排序+ 双指针：

1. 

##### Tips：

### 代码实现（Python）：

```python
class Solution:
    @staticmethod
    def arrange_numbers(nums):
        """
        原地重排数组，将每个正整数放置到其正确的位置上（即数字x应位于索引x-1处）

        参数:
            nums (list): 待处理的整数列表

        说明:
            该函数会直接修改输入数组
        """
        n = len(nums)
        i = 0
        while i < n:
            # 计算当前元素应在的正确位置
            correct_pos = nums[i] - 1

            # 检查是否需要交换：
            # 1. 当前元素是正整数
            # 2. 在数组范围内 (1 <= nums[i] <= n)
            # 3. 尚未在正确位置上 (nums[i] != nums[correct_pos])
            if 1 <= nums[i] <= n and nums[i] != nums[correct_pos]:
                # 交换当前元素到正确位置
                nums[i], nums[correct_pos] = nums[correct_pos], nums[i]
            else:
                # 如果不需要交换，移动到下一个元素
                i += 1

    @staticmethod
    def find_first_missing_positive(nums):
        """
        在已重排的数组中查找第一个缺失的正整数

        参数:
            nums (list): 经过arrange_numbers处理后的数组

        返回:
            int: 第一个缺失的正整数
        """
        n = len(nums)
        for i in range(n):
            # 当前位置的值应为i+1，否则i+1就是缺失的数字
            if nums[i] != i + 1:
                return i + 1
        # 所有位置都正确，缺失的是n+1
        return n + 1

    def firstMissingPositive(self, nums):
        """
        主函数：找出数组中缺失的最小正整数

        参数:
            nums (list): 未排序的整数数组

        返回:
            int: 未出现的最小正整数

        算法步骤:
            1. 使用原地重排算法整理数组
            2. 扫描整理后的数组找到第一个缺失的正整数
        """
        # 空数组的特殊情况处理
        if not nums:
            return 1

        # 步骤1: 原地重排数组
        Solution.arrange_numbers(nums)

        # 步骤2: 查找第一个缺失的正整数
        return Solution.find_first_missing_positive(nums)
```
