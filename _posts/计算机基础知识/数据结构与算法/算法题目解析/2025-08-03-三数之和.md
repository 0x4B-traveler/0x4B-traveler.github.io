---
layout: post
title:  "LeetCode: 15.三数之和"
date:   2025-08-03 22:47:14 +0800
categories: LeetCode 算法
---
## 15.三数之和

### 题目描述

```
给你一个整数数组 `nums` ，判断是否存在三元组 `[nums[i], nums[j], nums[k]]` 满足 `i != j`、`i != k` 且 `j != k` ，同时还满足 `nums[i] + nums[j] + nums[k] == 0` 。请你返回所有和为 `0` 且不重复的三元组。
注意：答案中不可以包含重复的三元组。
```

### 思考：

排序+ 双指针：

1. 先对 `nums`做升序排序
2. 然后遍历索引 `0 ~ len(nums) - 2`，因为三元组需要三个不同的元素，而我们需要遍历的是一个固定值，我们在固定值之后的区间内去寻找两个元素的和等于 `-固定值`的组合，所以遍历的索引是 `0 ~ len(nums) - 2`
3. 题目要求答案不可以包含重复的三元组，所以我们现需要在遍历固定值的内部逻辑里，做去重，即函数 `skip_duplicate_fixed`，因为重复的固定值没有意义，不符合题目要求，这里通过判断当前固定值和前一个固定值的大小，如果重复，可以减少后续不必要的操作
4. 然后我们把问题转换为：寻找区间 `[i : len(nums - 1)]`范围内两数之和等于 `-nums[i]`的组合，问题到这里就简化成了 `n - 2`次两数之和
5. 两数之和通过双指针（左右指针）的算法来实现：左指针的索引是 `i + 1`， 右指针是 `len(nums) - 1`，使用while循环，循环结束条件就是当左右指针相等时表示整个nums数组都被遍历完了，在while循环内部，需要再次对左右指针指向的内容做一次去重，即跳过左右侧的重复值，最后从函数 `find_two_sum`中获取到不包含重复的两元组，在外部函数 `process_fixed_element`再使用一个列表推导式，返回对于固定值 `nums[i]`所有和为 `0` 且不重复的三元组

##### Tips：

* len的复杂度是0(1)，因为列表的元数据里有记忆列表内当前的元素数，所以可以直接通过C语言的接口获取该证书数组对应的结构体对象内的属性
* `[]`比 `list()`效率更高，`[]`是一个内置的C函数，可以被直接调用；`list()`是一个 `function call`，·Python的 `function call`会创建 `stack`，并且进行一系列参数检查的操作，代价比较高；

### 代码实现（Python）：

```python
class Solution:
    def sort_array(self, nums: list[int]) -> None:
        """对数组进行原地排序"""
        nums.sort()

    def skip_duplicate_fixed(self, nums: list[int], i: int) -> bool:
        """检查并跳过重复的固定值"""
        return i > 0 and nums[i] == nums[i - 1]

    def find_two_sum(self, nums: list[int], start: int, target: int) -> list[list[int]]:
        """在已排序数组中查找两数之和等于目标值的所有组合"""
        left, right = start, len(nums) - 1
        pairs = []

        while left < right:
            total = nums[left] + nums[right]

            if total == target:
                pairs.append([nums[left], nums[right]])
                # 跳过左侧重复值
                while left < right and nums[left] == nums[left + 1]:
                    left += 1
                # 跳过右侧重复值
                while left < right and nums[right] == nums[right - 1]:
                    right -= 1
                left += 1
                right -= 1
            elif total < target:
                left += 1
            else:
                right -= 1

        return pairs

    def process_fixed_element(self, nums: list[int], i: int) -> list[list[int]]:
        """处理固定元素，查找匹配的三元组"""
        # 提前终止：当前数大于0时后续不可能组成0
        if nums[i] > 0:
            return []

        # 跳过重复的固定值
        if self.skip_duplicate_fixed(nums, i):
            return []

        # 在剩余数组中查找两数之和等于 -nums[i]
        target = -nums[i]
        pairs = self.find_two_sum(nums, i + 1, target)

        # 将固定值与找到的二元组组合成三元组
        return [[nums[i]] + pair for pair in pairs]

    def threeSum(self, nums: list[int]) -> list[list[int]]:
        """主方法：协调整个三数之和查找过程"""
        if len(nums) < 3:
            return []

        # 步骤1：排序数组
        self.sort_array(nums)

        # 步骤2：遍历每个可能的固定值
        triplets = []
        n = len(nums)

        for i in range(n - 2):
            # 处理当前固定元素并收集结果
            i_results = self.process_fixed_element(nums, i)
            triplets.extend(i_results)

        return triplets

```
