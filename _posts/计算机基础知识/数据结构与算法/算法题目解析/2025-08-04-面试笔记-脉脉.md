---
layout: post
title:  "面试复盘之脉脉"
date:   2025-08-04 22:47:14 +0800
categories: 工作 求职
---

## 面试复盘之脉脉

### 1. Redis Hash 如何获取

##### 核心命令：

 * `HGET key field`: 获取指定 key 中单个 field 的值。
 * `HMGET key field1 field2 ...` 获取指定 key 中多个 field 的值。
 * `HGETALL key`: 获取指定 key 中所有 field 及其值（返回一个列表，格式：field1, value1, field2, value2, ...）。
 * `HKEYS key`: 获取指定 key 中所有 field 的名称。
 *  `HVALS key`: 获取指定 key 中所有 field 的值。

##### 关键点：

* `HGETALL` 在 Hash 很大时可能阻塞 Redis 或消耗较多内存/网络带宽，需谨慎使用。
* 优先使用 `HGET/HMGET` 获取所需字段，避免全量获取。

### 2. Git Merge 和 Rebase 的异同点

| 特性         | Merge (合并)                       | Rebase (变基)                        |
| ------------ | ---------------------------------- | ------------------------------------ |
| **目的**     | 将两个分支的**最新状态**合并       | 将一个分支的提交**移植**到另一分支   |
| **提交历史** | 保留原始分支结构，生成新的合并提交 | **重写历史**，提交线变成一条直线     |
| **结果**     | 分支历史更复杂（体现合并点）       | 分支历史更简洁线性                   |
| **冲突处理** | 在最终合并时一次性解决冲突         | 在移植每个提交时可能需多次解决冲突   |
| **适用场景** | 公共分支（如 master）、长期分支    | **本地分支整理**、准备合并前清理历史 |
| **风险**     | 安全，不改变历史                   | **重写历史**，强制推送可能影响协作   |

> **核心差异：Merge 保留分支拓扑，Rebase 创造线性历史。**

### 3. Docker Exec 和 Run 的区别

| 命令         | `docker run`                          | `docker exec`                                     |
| ------------ | ------------------------------------- | ------------------------------------------------- |
| **作用**     | **创建并启动**一个新的容器            | **在已运行**的容器中执行命令                      |
| **容器状态** | 作用于**停止状态**的镜像              | 作用于**运行中**的容器                            |
| **结果**     | 生成新容器                            | 不创建新容器，只在现有容器内执行                  |
| **典型用途** | 启动应用服务（如 `docker run nginx`） | 调试容器（如 `docker exec -it mycontainer bash`） |

------

### 4. Docker 如何挂载外部文件

两种主要方式实现数据持久化：

1. **Bind Mount (绑定挂载)**
    - 语法：`docker run -v /宿主机/路径:/容器内/路径 ...`
    - **特点**：直接映射宿主机目录到容器，修改实时双向同步。
    - **适用场景**：开发环境（代码热更新）、配置文件挂载。
2. **Volume (数据卷)**
    - 创建卷：`docker volume create myvol`
    - 挂载：`docker run -v myvol:/容器内/路径 ...`
    - **特点**：由 Docker 管理，与宿主机路径解耦，适合生产环境。
    - **优点**：备份/迁移更方便，权限由 Docker 控制。

> **关键选择：** 需直接编辑宿主机文件用 `Bind Mount`；纯数据存储用 `Volume`。

------

### 5. HAVING 的使用场景

- **作用：** 对 **GROUP BY 分组后的结果**进行条件过滤（类似 WHERE，但作用于分组聚合结果）。
- **与 WHERE 区别：**
    - `WHERE` 在分组前过滤**原始行**。
    - `HAVING` 在分组后过滤**聚合结果**（如 sum/count/avg）。
- **示例：**

- ```sql
    SELECT department, AVG(salary) AS avg_salary
    FROM employees
    GROUP BY department
    HAVING AVG(salary) > 10000;  -- 筛选平均工资>1万的部门
    ```

------

### 6. TCP 和 UDP 的区别

| 特性         | TCP (传输控制协议)                    | UDP (用户数据报协议)                |
| ------------ | ------------------------------------- | ----------------------------------- |
| **连接性**   | **面向连接** (三次握手)               | **无连接** (直接发送数据包)         |
| **可靠性**   | **可靠传输** (确认/重传/排序)         | **不可靠** (可能丢失/乱序)          |
| **数据边界** | 字节流 (无明确边界)                   | 数据报 (保留发送边界)               |
| **速度**     | 较慢 (有连接和可靠性开销)             | **极快** (无额外控制)               |
| **拥塞控制** | 有复杂算法避免网络拥堵                | 无控制 (可能加剧拥堵)               |
| **头部大小** | 较大 (20-60字节)                      | 小 (仅8字节)                        |
| **应用场景** | 网页(HTTP)、邮件(SMTP)、文件传输(FTP) | 视频流、直播、DNS查询、游戏实时数据 |

------

### 7. HTTP 和 TCP 的区别

- **层级关系：**
    - `TCP` 是**传输层协议**：负责可靠的点对点数据传输。
    - `HTTP` 是**应用层协议**：构建在 TCP 之上，定义 Web 通信格式（请求/响应结构、方法、状态码、头部等）。
- **核心区别：**
    - **功能：** TCP 管**数据怎么可靠送达** ，HTTP 管**数据代表什么含义**。
    - **内容：** TCP 传输原始字节流，HTTP 传输有语义的文本（如 `GET /index.html HTTP/1.1`）。
- **类比：** TCP 是货运卡车，保证货物完整送达；HTTP 是货物包装上的订单信息，告诉仓库如何处理。

------

### 8. 购物车测试用例设计

**核心测试维度：**

1. **功能测试：**
    - 添加商品（不同种类/数量/库存状态）
    - 删除商品（单个/批量）
    - 修改数量（增/减/输入值/超库存限制）
    - 商品选择（全选/反选/部分选）
    - 价格计算（单价、总价、折扣、运费实时更新）
    - 未登录时添加，登录后是否保留
2. **边界/异常测试：**
    - 添加 0 件商品
    - 添加负数商品
    - 超库存添加（提示是否合理）
    - 商品下架/删除后购物车状态
    - 网络中断时操作
3. **兼容性测试：**
    - 浏览器（Chrome/Firefox/Safari/Edge）
    - 设备（PC/手机/平板）
    - 操作系统（Windows/macOS/iOS/Android）
4. **性能测试：**
    - 加载含大量商品的购物车
    - 高并发下添加/删除商品
5. **安全测试：**
    - 越权操作（修改他人购物车）
    - 价格篡改（前端校验绕过）

------

### 9. 协程、线程和进程的异同点

| 特性         | 进程 (Process)                | 线程 (Thread)                 | 协程 (Coroutine)               |
| ------------ | ----------------------------- | ----------------------------- | ------------------------------ |
| **资源分配** | 操作系统分配独立内存空间      | **共享进程内存**              | **共享线程内存**               |
| **切换开销** | 最大 (需切换内存空间)         | 中等 (需内核调度)             | **极小** (用户态切换)          |
| **并发性**   | 多进程并行                    | 多线程并行                    | **高并发** (单线程内调度)      |
| **通信方式** | 管道、Socket、共享内存 (复杂) | 共享变量 (需同步锁)           | 共享变量 (通常无锁)            |
| **创建数量** | 少 (受内存限制)               | 较多 (受内核限制)             | **极多** (如Go可百万级)        |
| **隔离性**   | **强** (崩溃不影响其他进程)   | 弱 (线程崩溃可能导致进程退出) | 弱 (协程崩溃影响所属线程)      |
| **控制权**   | 操作系统调度                  | 操作系统调度                  | **用户程序调度**               |
| **典型场景** | 独立应用 (Chrome浏览器多进程) | CPU密集型任务、阻塞操作       | **I/O密集型** (网络服务、爬虫) |

> **协程核心优势：** 在 I/O 等待时主动让出 CPU，最大化单线程利用率，避免线程切换开销。