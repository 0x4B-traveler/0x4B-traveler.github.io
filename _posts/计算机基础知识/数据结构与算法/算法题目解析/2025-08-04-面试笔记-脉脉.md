---
layout: post
title:  "面试复盘之脉脉"
date:   2025-08-04 22:47:14 +0800
categories: 工作 求职
---

## 面试复盘之脉脉

### 1. Redis Hash 如何获取

##### 核心命令：

 * `HGET key field`: 获取指定 key 中单个 field 的值。
 * `HMGET key field1 field2 ...` 获取指定 key 中多个 field 的值。
 * `HGETALL key`: 获取指定 key 中所有 field 及其值（返回一个列表，格式：field1, value1, field2, value2, ...）。
 * `HKEYS key`: 获取指定 key 中所有 field 的名称。
 *  `HVALS key`: 获取指定 key 中所有 field 的值。

##### 关键点：

* `HGETALL` 在 Hash 很大时可能阻塞 Redis 或消耗较多内存/网络带宽，需谨慎使用。
* 优先使用 `HGET/HMGET` 获取所需字段，避免全量获取。

### 2. Git Merge 和 Rebase 的异同点

| 特性         | Merge (合并)                       | Rebase (变基)                        |
| ------------ | ---------------------------------- | ------------------------------------ |
| **目的**     | 将两个分支的**最新状态**合并       | 将一个分支的提交**移植**到另一分支   |
| **提交历史** | 保留原始分支结构，生成新的合并提交 | **重写历史**，提交线变成一条直线     |
| **结果**     | 分支历史更复杂（体现合并点）       | 分支历史更简洁线性                   |
| **冲突处理** | 在最终合并时一次性解决冲突         | 在移植每个提交时可能需多次解决冲突   |
| **适用场景** | 公共分支（如 master）、长期分支    | **本地分支整理**、准备合并前清理历史 |
| **风险**     | 安全，不改变历史                   | **重写历史**，强制推送可能影响协作   |

> **核心差异：Merge 保留分支拓扑，Rebase 创造线性历史。**

### 3. Docker Exec 和 Run 的区别

| 命令         | `docker run`                          | `docker exec`                                     |
| ------------ | ------------------------------------- | ------------------------------------------------- |
| **作用**     | **创建并启动**一个新的容器            | **在已运行**的容器中执行命令                      |
| **容器状态** | 作用于**停止状态**的镜像              | 作用于**运行中**的容器                            |
| **结果**     | 生成新容器                            | 不创建新容器，只在现有容器内执行                  |
| **典型用途** | 启动应用服务（如 `docker run nginx`） | 调试容器（如 `docker exec -it mycontainer bash`） |

------

### 4. Docker 如何挂载外部文件

两种主要方式实现数据持久化：

1. **Bind Mount (绑定挂载)**
    - 语法：`docker run -v /宿主机/路径:/容器内/路径 ...`
    - **特点**：直接映射宿主机目录到容器，修改实时双向同步。
    - **适用场景**：开发环境（代码热更新）、配置文件挂载。
2. **Volume (数据卷)**
    - 创建卷：`docker volume create myvol`
    - 挂载：`docker run -v myvol:/容器内/路径 ...`
    - **特点**：由 Docker 管理，与宿主机路径解耦，适合生产环境。
    - **优点**：备份/迁移更方便，权限由 Docker 控制。

> **关键选择：** 需直接编辑宿主机文件用 `Bind Mount`；纯数据存储用 `Volume`。

------

### 5. HAVING 的使用场景

- **作用：** 对 **GROUP BY 分组后的结果**进行条件过滤（类似 WHERE，但作用于分组聚合结果）。
- **与 WHERE 区别：**
    - `WHERE` 在分组前过滤**原始行**。
    - `HAVING` 在分组后过滤**聚合结果**（如 sum/count/avg）。
- **示例：**

- ```sql
    SELECT department, AVG(salary) AS avg_salary
    FROM employees
    GROUP BY department
    HAVING AVG(salary) > 10000;  -- 筛选平均工资>1万的部门
    ```

------

### 6. TCP 和 UDP 的区别

| 特性         | TCP (传输控制协议)                    | UDP (用户数据报协议)                |
| ------------ | ------------------------------------- | ----------------------------------- |
| **连接性**   | **面向连接** (三次握手)               | **无连接** (直接发送数据包)         |
| **可靠性**   | **可靠传输** (确认/重传/排序)         | **不可靠** (可能丢失/乱序)          |
| **数据边界** | 字节流 (无明确边界)                   | 数据报 (保留发送边界)               |
| **速度**     | 较慢 (有连接和可靠性开销)             | **极快** (无额外控制)               |
| **拥塞控制** | 有复杂算法避免网络拥堵                | 无控制 (可能加剧拥堵)               |
| **头部大小** | 较大 (20-60字节)                      | 小 (仅8字节)                        |
| **应用场景** | 网页(HTTP)、邮件(SMTP)、文件传输(FTP) | 视频流、直播、DNS查询、游戏实时数据 |

------

### 7. HTTP 和 TCP 的区别

- **层级关系：**
    - `TCP` 是**传输层协议**：负责可靠的点对点数据传输。
    - `HTTP` 是**应用层协议**：构建在 TCP 之上，定义 Web 通信格式（请求/响应结构、方法、状态码、头部等）。
- **核心区别：**
    - **功能：** TCP 管**数据怎么可靠送达** ，HTTP 管**数据代表什么含义**。
    - **内容：** TCP 传输原始字节流，HTTP 传输有语义的文本（如 `GET /index.html HTTP/1.1`）。
- **类比：** TCP 是货运卡车，保证货物完整送达；HTTP 是货物包装上的订单信息，告诉仓库如何处理。

------

### 8. 购物车测试用例设计

**核心测试维度：**

1. **功能测试：**
    - 添加商品（不同种类/数量/库存状态）
    - 删除商品（单个/批量）
    - 修改数量（增/减/输入值/超库存限制）
    - 商品选择（全选/反选/部分选）
    - 价格计算（单价、总价、折扣、运费实时更新）
    - 未登录时添加，登录后是否保留
2. **边界/异常测试：**
    - 添加 0 件商品
    - 添加负数商品
    - 超库存添加（提示是否合理）
    - 商品下架/删除后购物车状态
    - 网络中断时操作
3. **兼容性测试：**
    - 浏览器（Chrome/Firefox/Safari/Edge）
    - 设备（PC/手机/平板）
    - 操作系统（Windows/macOS/iOS/Android）
4. **性能测试：**
    - 加载含大量商品的购物车
    - 高并发下添加/删除商品
5. **安全测试：**
    - 越权操作（修改他人购物车）
    - 价格篡改（前端校验绕过）

------

### 9. 协程、线程和进程的异同点

| 特性         | 进程 (Process)                | 线程 (Thread)                 | 协程 (Coroutine)               |
| ------------ | ----------------------------- | ----------------------------- | ------------------------------ |
| **资源分配** | 操作系统分配独立内存空间      | **共享进程内存**              | **共享线程内存**               |
| **切换开销** | 最大 (需切换内存空间)         | 中等 (需内核调度)             | **极小** (用户态切换)          |
| **并发性**   | 多进程并行                    | 多线程并行                    | **高并发** (单线程内调度)      |
| **通信方式** | 管道、Socket、共享内存 (复杂) | 共享变量 (需同步锁)           | 共享变量 (通常无锁)            |
| **创建数量** | 少 (受内存限制)               | 较多 (受内核限制)             | **极多** (如Go可百万级)        |
| **隔离性**   | **强** (崩溃不影响其他进程)   | 弱 (线程崩溃可能导致进程退出) | 弱 (协程崩溃影响所属线程)      |
| **控制权**   | 操作系统调度                  | 操作系统调度                  | **用户程序调度**               |
| **典型场景** | 独立应用 (Chrome浏览器多进程) | CPU密集型任务、阻塞操作       | **I/O密集型** (网络服务、爬虫) |

> **协程核心优势：** 在 I/O 等待时主动让出 CPU，最大化单线程利用率，避免线程切换开销。

### 10. 理解 `session`、`cookie` 和 `token`

1. **Cookie**
    - **是什么？** 一个由服务器发送到用户浏览器并存储在本地的小型文本文件（通常最大 4KB）。
    - **目的：**
        - **状态管理：** HTTP 协议本身是无状态的。Cookie 允许服务器在多个请求之间“记住”用户或会话信息。
        - **存储：** 存储一些偏好设置（如语言、主题）、跟踪信息（需遵守隐私法规）或身份验证凭据（如 Session ID 或 Token）。
    - **工作原理：**
        1. 服务器在 HTTP 响应头中设置 Cookie（`Set-Cookie: name=value; attributes`）。
        2. 浏览器收到响应后，将 Cookie 存储起来（根据路径、域名、有效期等属性）。
        3. 之后**每次**向**同一域名和路径**发送 HTTP 请求时，浏览器会自动在请求头中包含该 Cookie（`Cookie: name=value; othername=othervalue`）。
        4. 服务器读取请求头中的 Cookie 来获取信息。
    - **关键属性：**
        - `Name` & `Value`: 键值对。
        - `Domain` & `Path`: 指定 Cookie 生效的范围。
        - `Expires` / `Max-Age`: 设置 Cookie 的过期时间（会话 Cookie 在浏览器关闭时过期；持久 Cookie 在指定时间后过期）。
        - `HttpOnly`: 设置为 `true` 时，Cookie 仅可通过 HTTP(S) 传输，**不能被 JavaScript 访问**，是重要的安全措施（防 XSS 窃取）。
        - `Secure`: 设置为 `true` 时，Cookie **仅通过 HTTPS** 连接传输。
        - `SameSite`: 控制 Cookie 是否在跨站请求中发送（`Strict`, `Lax`, `None`），是重要的安全措施（防 CSRF）。
    - **优点：** 自动管理（浏览器发送），简单易用，支持过期时间。
    - **缺点：** 大小限制，存在安全风险（需正确设置 `HttpOnly`, `Secure`, `SameSite`），可能被用户禁用，每次请求都携带增加带宽开销。
2. **Session**
    - **是什么？** **服务器端**存储的与特定用户相关联的状态信息。它不是直接发送给客户端的。
    - **目的：** 在服务器上维护用户的状态，比如登录状态、购物车内容、表单数据等，跨越多个 HTTP 请求。
    - **工作原理 (通常结合 Cookie 使用 - Session ID Cookie)：**
        1. 用户首次访问或登录时，服务器为该用户创建一个唯一的 `Session ID`，并在服务器上开辟一块存储空间（内存、文件、数据库、缓存如 Redis）来存储与该 Session ID 关联的用户数据（session 数据）。
        2. 服务器在 HTTP 响应中将这个 `Session ID` **通过一个 Cookie**（通常是名为 `JSESSIONID` 或 `PHPSESSID` 等）发送给浏览器。
        3. 浏览器存储这个包含 Session ID 的 Cookie。
        4. 后续该浏览器向同一服务器发送请求时，**自动带上这个 Cookie**。
        5. 服务器从请求 Cookie 中读取 `Session ID`，然后使用这个 ID 在服务器存储中查找对应的 session 数据。找到后，服务器就知道这是哪个用户以及其状态信息。
    - **关键点：**
        - **核心数据在服务器：** Session 的核心是存储在服务器上的用户状态数据。
        - **Session ID 是关键纽带：** Session ID 是连接客户端（通过 Cookie 携带）和服务器端 Session 数据的桥梁。这个 ID 通常是随机的、难以猜测的。
        - **依赖 Cookie (最常见)：** Session 机制最常见的方式就是依赖 Cookie 来传递 Session ID。如果没有 Cookie（或替代机制如 URL 重写），标准的 Session 机制很难有效工作。
        - **服务器资源：** 服务器需要存储所有活跃 session 的数据，用户量大时可能成为瓶颈（因此常使用分布式缓存如 Redis 来存储 session）。
    - **优点：** 敏感数据安全地存储在服务器端，不受客户端存储限制。
    - **缺点：** 服务器有状态（需要存储 session 数据），扩展性挑战（需要共享 session 存储），依赖客户端机制（通常是 Cookie）传递 Session ID。
3. **Token (通常指 JWT - JSON Web Token，或其他类似令牌)**
    - **是什么？** 一个**自包含**的、通常经过数字签名的字符串，由服务器生成并发送给客户端。客户端在后续请求中将其返回给服务器用于验证身份和授权。
    - **目的：** 一种**无状态**的身份验证和授权机制。服务器不需要在本地存储会话信息。
    - **工作原理 (以 JWT 为例)：**
        1. **登录/认证：** 用户提供凭据（如用户名密码）登录。
        2. **生成 Token：** 服务器验证凭据有效后，创建一个 JWT。JWT 包含三部分（用`.`分隔）：
            - **Header:** 说明 token 类型（如 JWT）和使用的签名算法（如 HS256, RS256）。
            - **Payload (Claims):** 包含有关用户和实体的声明（claims），例如用户 ID、用户名、角色、过期时间 (`exp`) 等。
            - **Signature:** 使用服务器持有的密钥（或私钥）对编码后的 Header + `.` + 编码后的 Payload 进行签名。签名确保 Token 的完整性和来源可信（未被篡改且是特定服务器颁发的）。
        3. **发送 Token：** 服务器将生成的 JWT 发送给客户端（通常放在 HTTP 响应体或响应头如 `Authorization: Bearer <token>` 中）。
        4. **客户端存储：** 客户端（浏览器、移动 App）收到 Token 后，需要自行存储（通常存储在 `localStorage`, `sessionStorage` 或内存中，**或者一个安全配置的 Cookie 中**）。
        5. **后续请求：** 客户端在访问受保护资源时，在请求中携带这个 Token（通常放在 HTTP 请求头 `Authorization: Bearer <token>` 中）。
        6. **服务器验证：** 服务器收到请求后：
            - 从 `Authorization` 头中提取 Token。
            - **验证签名：** 使用密钥（或公钥，对于 RS256）验证 Token 的签名是否有效，确保 Token 未被篡改且是自己颁发的。
            - **检查声明：** 验证 Token 是否在有效期内（检查 `exp`），检查用户权限（检查 `roles` 等声明）是否满足访问资源的要求。
            - 如果验证通过，则处理请求；否则，拒绝请求（返回 401/403）。
    - **关键点：**
        - **无状态：** 服务器不需要存储 Token 本身。验证 Token 的有效性只需要验证签名和检查 Payload 中的声明（如过期时间）。这是与 Session 的最大区别。
        - **自包含：** Token（特别是 JWT）的 Payload 包含了用户信息，服务器可以直接从中读取，无需额外查库（但要注意 Payload 不宜过大，且不要放敏感信息）。
        - **可验证 & 可信：** 签名机制保证只有持有密钥的服务器才能生成或修改有效的 Token。
        - **存储位置灵活：** Token 可以存储在 `localStorage`, `sessionStorage`, 内存，或一个安全配置的 Cookie 中。选择哪种方式需要权衡安全性和需求（如跨标签页、防 XSS、防 CSRF）。
        - **跨域友好：** 非常适合 API 服务（如 RESTful API）、单页应用（SPA）、移动应用和微服务架构，因为它不依赖 Cookie 的同源策略限制（CORS 配置得当即可）。
    - **优点：** 无状态（服务器扩展性好），跨域支持好，适用于多种客户端（Web, Mobile, API），自包含可减少数据库查询（需谨慎）。
    - **缺点：** Token 一旦发出，在有效期内很难使其失效（需要额外的黑名单机制如 Token 撤销列表），Payload 默认不加密（JWT  是签名不是加密，敏感信息应避免放入或使用 JWE），需要客户端安全存储（防 XSS 窃取），Token 可能比 Session ID  大增加请求开销。

**总结与关系：**

- **Cookie：** 是 **HTTP 协议层面**的一种在**客户端（浏览器）存储数据**并由**浏览器自动管理发送**的机制。它是存储和传递 Session ID 或 Token 的一种**载体**（Transport Mechanism）。
- **Session：** 是 **服务器端**存储用户状态信息的机制。它通常**依赖 Cookie**（存储 Session ID）来关联客户端请求和服务器端的 Session 数据。Session 是**有状态**的。
- **Token (JWT)：** 是一种**自包含的、无状态的凭证**。它包含用户信息和验证签名。Token 可以**通过多种方式传输**，最常见的是通过 HTTP 头（如 `Authorization: Bearer`），但也可以**存储在一个 Cookie 中**进行传输（这时的 Cookie 只是 Token 的容器）。Token 认证本身是**无状态**的。

**简单比喻：**

- **Cookie** 就像你的钱包或口袋，用来装东西（比如会员卡号、一张写有俱乐部准入规则的纸条）。
- **Session (ID)** 就像俱乐部的**会员卡号**。你（浏览器）把卡号（Session ID）放在钱包（Cookie）里带着。每次去俱乐部（服务器），你把卡号给前台。前台（服务器）根据卡号去查厚厚的会员登记簿（Session 存储）找到你的档案（Session 数据），才知道你是谁、有什么权限。
- **Token (JWT)** 就像俱乐部给你的一张**加密签名的会员卡**。这张卡上直接印着你的名字（User  ID）、会员等级（Role）和有效期（Expiry），并且有俱乐部的特殊防伪印章（Signature）。你（客户端）带着这张卡（在钱包里或手里拿着）。每次去俱乐部，直接把卡给前台看。前台用特殊的灯（密钥）照一下防伪印章确认是真的，然后直接看卡上的信息就知道你是谁、能做什么了，不需要去翻登记簿。

**选择建议：**

- **传统的、有状态的 Web 应用：** 通常使用 **Session + Session ID Cookie**。简单直接，敏感数据在服务器。
- **API 优先、无状态后端、SPA、移动应用、跨域服务、微服务：** 通常使用 **Token (JWT) 认证**。通过 HTTP Header 传递，无状态扩展性好。如果需要 Cookie 的特性（如自动发送、同源策略下的安全性），可以将 Token 存储在 `HttpOnly`、`Secure`、`SameSite=Strict/Lax` 的 Cookie 中（这被称为 Cookie-based Token Auth）。
- **“记住我”功能：** 通常使用一个长期有效的 Token（Refresh Token）或一个设置了很长 `Max-Age` 的 Session ID Cookie。