---
layout: post
title:  "LeetCode: 139.单词拆分"
date:   2025-08-05 22:47:14 +0800
categories: LeetCode 算法
---
## 139.单词拆分

### 题目描述

```
给你一个字符串 s 和一个字符串列表 wordDict 作为字典。如果可以利用字典中出现的一个或多个单词拼接出 s 则返回 true。
注意：不要求字典中出现的单词全部都使用，并且字典中的单词可以重复使用。
```

### 思考：

贪心策略（通过替换字符串）：考虑不够全面

动态规划：具体解释放到之后

##### Tips：

### 代码实现（Python）：

```python
class Solution:
    def wordBreak(self, s: str, wordDict: List[str]) -> bool:
        # 边界情况处理
        if not self._validate_input(s, wordDict):
            return False

        # 预处理字典数据
        word_set, max_word_len = self._preprocess_word_dict(wordDict)

        # 使用动态规划解决问题
        return self._dp_solution(s, word_set, max_word_len)

    def _validate_input(self, s: str, wordDict: List[str]) -> bool:
        """验证输入有效性"""
        if s is None or wordDict is None:
            return False
        if len(wordDict) == 0:
            return len(s) == 0
        return True

    def _preprocess_word_dict(self, wordDict: List[str]) -> tuple:
        """预处理字典：转换为集合并计算最大单词长度"""
        word_set = set(wordDict)
        max_word_len = max(len(word) for word in word_set) if word_set else 0
        return word_set, max_word_len

    def _dp_solution(self, s: str, word_set: set, max_word_len: int) -> bool:
        """动态规划解决方案核心逻辑"""
        n = len(s)
        dp = [False] * (n + 1)
        dp[0] = True  # 空字符串总是可分割

        for i in range(1, n + 1):
            # 确定检查范围的起始位置（优化关键）
            start = max(0, i - max_word_len) if max_word_len > 0 else 0

            # 检查所有可能的子串分割点
            for j in range(start, i):
                if dp[j] and self._is_valid_word(s, j, i, word_set):
                    dp[i] = True
                    break  # 找到有效分割即可跳出

        return dp[n]

    def _is_valid_word(self, s: str, start: int, end: int, word_set: set) -> bool:
        """检查子串是否为有效单词"""
        return s[start:end] in word_set
```
